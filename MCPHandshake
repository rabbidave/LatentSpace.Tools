Handshake MCP Architecture
A secure integration pattern for connecting AI assistants with sensitive operations through coordinated, transaction-specific authentication protocols.
Core Concepts
1. Coordinated Components
This architecture consists of two primary components that work through a secure handshake mechanism:
Local MCP Server: Deployed on the user's device or local environment; responsible for initiating transaction requests.
Remote MCP Service: Serverless function or dormant/hibernated service that awaits handshake signals to execute sensitive operations.
These components establish trust through a cryptographically verified handshake protocol while maintaining independent security contexts. User authentication (establishing user identity to the Remote Service) may precede the transaction-specific handshake.
2. Just-in-Time Resource Allocation
Resources are allocated only when needed for a specific transaction:
Remote services remain dormant or scale to zero when inactive.
New, isolated instances can be spawned for each operation or handshake phase.
Compute resources are consumed ephemerally, aligning cost with activity.
3. Transaction-Bound Ephemeral Auth
Each sensitive operation requires a distinct, two-phase handshake explicitly bound to that specific transaction instance:
Phase 1: Authorization Request: The authenticated user requests authorization for a specific target operation with defined parameters.
Phase 2: Ephemeral Token Grant & Consumption: Upon successful authorization, a unique, single-use Ephemeral Transaction Token (e.g., a nonce or short-lived capability token) is generated and returned. This token is:
Tied cryptographically (e.g., via state store reference and parameter hashing) to the specific transaction UUID, authorized user, target operation, and parameters.
Limited in scope strictly to the single authorized business operation instance.
Given a very short expiration period (e.g., seconds), sufficient only to be immediately used in the subsequent operation call.
Managed via a secure state store (e.g., KV store, cache) where its validity (pending status) is tracked.
Token Consumption: The Ephemeral Transaction Token is presented alongside the operation request and is atomically consumed (e.g., state marked used or deleted) upon successful validation before the sensitive operation executes, preventing replay.
Verification receipts confirm the token's lifecycle (issuance, consumption, or expiration).
Architecture Diagram
┌─────────────────┐                   ┌─────────────────────────┐
│                 │                   │                         │
│   AI Assistant  │                   │ User Identity Provider  │
│  (MCP Client /  │                   │      (Session Auth)     │
│ Local MCP Server) │                   │                         │
│                 │                   └───────────┬─────────────┘
└───────┬─────────┘                               │ Session Token
        │                                         │ (e.g., JWT)
        │                                         │
        │ 1. Auth Req (Tool + Params)             ▼
        ├─────────────────────────────────>┌─────────────────┐
        │         (Session Token)          │                 │
        │                                  │   Remote MCP    │
        │ 2. Ephemeral Tx Token <----------│     Service     │
        │                                  │  (Cloudflare    │
        │ 3. Execute Tool (Tool + Params)  │    Worker)      │
        ├─────────────────────────────────>│                 │
        │   (Session Token +              │       +         │
        │    Ephemeral Tx Token Header)    │   State Store   │
        │                                  │    (e.g., KV)   │
        │ 4. Result + Proof <--------------│                 │
        │                                  └───────┬─────────┘
        │                                          │
        │                                          │ Consumes Tx Token,
        │                                          │ Calls Service API
        │                                          ▼
        │                            ┌─────────────────────────┐
        │                            │                         │
        │                            │    Secure VPC/Cloud     │
        │                            │    Environment          │
        │                            │  ┌───────────────────┐  │
        │                            │  │                   │  │
        │                            │  │ Sensitive Service │  │
        │                            │  │ APIs with keys    │  │
        │                            │  │                   │  │
        │                            │  └───────────────────┘  │
        │                            │                         │
        │                            └─────────────────────────┘
Use code with caution.
Operational Flow
Initialization:
User activates the local MCP client/server.
User authenticates to the Remote MCP Service via standard OAuth/JWT flows, obtaining a primary Session Token.
Local client prepares for transaction-specific handshakes.
Transaction Binding & Authorization Request:
AI assistant initiates a transaction (e.g., "Create invoice for X").
Local client identifies the target tool (e.g., createPayPalInvoice) and parameters.
Local client sends an Authorization Request call to a dedicated endpoint on the Remote MCP Service, passing the target tool, parameters, and the user's Session Token.
Remote service validates the Session Token, generates a unique transactionId, hashes parameters, and checks user permissions for the requested operation.
Ephemeral Token Grant (Handshake Phase 1 Complete):
Remote service generates a unique, single-use Ephemeral Transaction Token (nonce).
Remote service stores the transaction state (transactionId, userId, targetTool, paramsHash, status: pending, short expiry) in a secure state store (e.g., KV), keyed by the Ephemeral Transaction Token.
Remote service returns the transactionId and the Ephemeral Transaction Token to the Local client.
Operation Execution (Handshake Phase 2):
Local client immediately constructs the actual operation request (e.g., call createPayPalInvoice tool).
Local client sends the operation request to the Remote MCP Service, passing:
The user's Session Token (e.g., Authorization: Bearer ...).
The Ephemeral Transaction Token (e.g., X-Transaction-Authorization: ... header).
The required operation parameters.
Remote service validates the Session Token again.
Remote service retrieves the transaction state from the store using the Ephemeral Transaction Token.
Crucially: The service atomically consumes the token (e.g., deletes the state entry) and validates its expiry, user, tool, and parameter hash against the current request.
Sensitive Operation & Proof Generation:
If ephemeral token validation succeeds, the Remote MCP Service executes the sensitive operation (e.g., calls PayPal API) using the validated transactionId for idempotency.
Cryptographic proofs are generated, bound to the transactionId.
Results and the complete proof chain are returned securely to the Local client.
Local client validates the cryptographic receipts.
Handshake Termination:
The Ephemeral Transaction Token is already invalidated/consumed (Step 4). Timed-out tokens expire naturally via TTL in the state store.
Operation receipt and audit logs (including transactionId) are persisted.
Remote service instance may return to hibernation.
Secure connection related to the specific operation call is closed.
Cryptographic Receipts and Proofs
The architecture employs several cryptographic techniques to create verifiable, tamper-proof evidence of transactions:
Non-Repudiation Implementation
Digital Signatures: Transaction-specific digital signatures using the recipient's public key are created for each operation, providing proof of both origin and integrity of data
Cryptographic Hash Chains: Each step of the transaction creates a hash that includes the previous step's hash, forming an unbreakable chain of evidence
Timestamped Merkle Proofs: Transaction details are inserted into Merkle trees with trusted timestamps to prove exactly when each action occurred
Transaction Binding: All proofs are cryptographically bound to the specific transaction UUID (transactionId) using collision-resistant hashing
Guarantees Provided
Origin Authentication: Cryptographic proof of which entity initiated the transaction (via session token and transaction token binding).
Receipt Verification: Proof that the recipient received the specific message or transaction result.
Sequence Validation: Cryptographic evidence of the exact order of operations within the transaction context.
Integrity Protection: Tamper-evident seals that make any modification to the transaction data detectable.
Temporal Proof: Cryptographically verifiable evidence of when each step occurred.
Security Benefits
Zero Standing Privileges
No long-lived tokens grant direct access to sensitive operations.
The user's Session Token only grants the privilege to request a transaction authorization, not execute it.
The Ephemeral Transaction Token grants privilege only for the specifically authorized operation instance, is single-use, time-bound (seconds), and immediately consumed/destroyed upon validation.
Principle of least privilege is enforced dynamically at the transaction level via the ephemeral token mechanism.
Isolated Contexts
Each handshake establishes an isolated security context for the specific transaction.
Compromise of one session token does not automatically grant execution rights; compromise of an ephemeral token affects only one inflight transaction.
Clear security boundaries between handshake participants and phases.
Reduced Attack Surface
Sensitive components only execute logic after successful validation of both session and ephemeral tokens.
Minimal network exposure of critical services; ephemeral tokens reduce the window for credential misuse.
Defense-in-depth through layered authentication (session + transaction).
Enhanced Audit Trail
Distinct transactionId for each authorized operation attempt.
Clear tracking of authorization requests, ephemeral token issuance, consumption attempts (success/failure), and final operation execution.
Detailed logs associate user identity, client, requested operation, parameters (hashed), and timing for each step.
Implementation Considerations
Sensitivity Policy Management
Clear definition and secure management of sensitivity tags assigned by the Local MCP or inferred by the Remote Service based on the target tool.
Differential requirements for transaction authorization based on sensitivity (e.g., requiring MFA during session auth, stricter parameter validation).
Potential pre-registration of users/keys if digital signatures are incorporated into receipts.
Cryptographic enforcement (parameter hashing, token consumption) forms part of the policy enforcement.
Conditional Logic Implementation
Remote MCP Service requires logic to:
Validate session tokens.
Authorize requests based on user permissions and target tool.
Generate and store ephemeral token state.
Atomically validate and consume ephemeral tokens, including parameter hash checks.
Conditionally execute backend operations.
Generate appropriate cryptographic receipts.
Complexity managed through clear separation of concerns (session auth vs. transaction auth vs. execution).
Hibernation Management
Optimal hibernation policies based on usage patterns (relevant for non-serverless deployments).
Cold start latency primarily impacts the initial session validation or authorization request. The short lifetime of the ephemeral token necessitates low latency between authorization and execution calls.
State (pending ephemeral tokens) preserved reliably in the external state store (e.g., KV).
Transaction-Bound Token Lifecycle
A two-phase protocol (authorize->execute) manages the lifecycle.
Ephemeral Transaction Tokens are typically nonces or opaque strings whose state is managed server-side (e.g., in KV).
State must include bindings to transactionId, userId, targetTool, paramsHash, and a short expiry.
Atomic Consumption (e.g., KV delete checked against prior existence) upon validation is the primary revocation mechanism, preventing replays. KV TTL handles expiry.
Parameter hashing ensures the token cannot be reused for the same tool with different inputs.
Tokens are inherently non-transferable and single-operation scoped by the validation logic.
Advantages Over Traditional Integrations
Superior Security Isolation: Strong separation between user session authentication and fine-grained, single-use transaction execution authorization.
Cost Efficiency: Serverless/hibernating remote services consume resources only during active authorization or execution phases.
Compliance Advantages: Clear, auditable trail demonstrating explicit, parameter-bound authorization for every sensitive operation via the ephemeral token lifecycle.
Flexible Provider Integration: Works with standard identity providers (OAuth/JWT) for session management while layering transaction-specific controls.
Minimal Persistent Attack Surface: Reduces risk by eliminating standing privileges and ensuring execution tokens are single-use and time-limited to seconds.
